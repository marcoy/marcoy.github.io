= Stackless Scala, Part 3: Applying Trampoline
:page-layout: post
:page-categories: articles
:page-tags: scala, functional programming
:page-liquid:

:part1: link:{% post_url 2016-09-08-stackless-scala-1-the-problem %}
:part2: link:{% post_url 2016-09-11-stackless-scala-2-trampoline %}
:stackless-pdf: http://blog.higher-order.com/assets/trampolines.pdf

== Quick Recap
In the {part2}[previous] post,
the technique of trampoline was introduced in {stackless-pdf}[RÃºnar's paper].
Trampoline was used to solve the stack safety problem in the simple `even` and `odd` examples.
At the end of the {part2}[last] post,
I mentioned the logical next step would be applying the trampoline technique to the `zipIndex`
example introduced in the {part1}[first] post.

For reference, here is what the `Trampoline` data type looks like.

[[trampoline]]
[source,scala,lineno]
.Trampoline
----
sealed trait Trampoline[+A] {
  @tailrec
  final def runT: A =
    this match {
      case More(k) => k().runT
      case Done(v) => v
    }
}
case class More[+A](k: () => Trampoline[A])
    extends Trampoline[A]
case class Done[+A](result: A) extends Trampoline[A]
----

== Applying Trampoline to State
Since the stack safety problem comes from calling `flatMap` in `State` action,
perhaps, we can change the implementation of `State` to use trampoline.

Here is what the new `State` looks like.

[[state_trampoline]]
[source,scala,lineno]
.State with Trampoline
----
case class State[S,+A](
    runS: S => Trampoline[(A,S)]) { // <1>
  def map[B](f: A => B): State[S,B] =
    State[S,B](s => More(() => {
      val (a, s1) = runS(s).runT
      Done((f(a), s1))
    }))

  def flatMap[B](f: A => State[S,B]): State[S,B] =
    State[S,B](s => More(() => {
      val (a, s1) = runS(s).runT
      More(() => f(a) runS s1)
    }))
}
----
<1> `runS` returns `Trampoline[(A,S)]`.

And, `zipIndex` needs a slight change.

[source,scala,lineno]
----
def zipIndex[A](as: List[A]): List[(Int,A)] =
  as.foldLeft(
    pureState[Int, List[(Int,A)]](List())
  )((acc,a) => for {
    xs <- acc
    n  <- getState[Int]
    _  <- setState(n + 1)
  } yield (n,a)::xs).runS(0).runT._1.reverse // <1>
----
<1> Adding `runT` after `runS`.

However, if we run the latest incarnation of `zipIndex` above.
We get `StackoverflowError` again!?
The problem, this time, is caused my `runT` is not in the tail position of `flatMap`.
As seen on line 11 of the <<state_trampoline,State with Trampoline>> listing.

At this stage, the paper suggested baking in `flatMap` into the `Trampoline` data type.
So, we add a new case class that extends the `Trampoline` trait.

[source,scala,lineno]
----
case class More[+A](k: () => Trampoline[A])
  extends Trampoline[A]
case class Done[+A](result: A) extends Trampoline[A]
case class FlatMap[A,+B]( // <1>
  sub: Trampoline[A]
  k: A => Trampoline[B]) extends Trampoline[B]
----
<1> The new `FlatMap` case class.

Recall that, a `Done` tells trampoline that the computation is done,
and use the value inside `Done` as the return value.
A `More` tells trampoline that there are at least one more steps to perform for the computation,
perform the step.
The new `FlatMap` tells trampoline that there is a computation, `sub`,
and the return value of `sub` should be passed to the continuation, `k`.
Since we added a new case class,
the implementation of `runT` needs to be updated.
In the paper, the updated `runT` implementation is split into two pieces --
one piece is to determine how to advance the computation;
the other piece is to run the steps in the computation.

[source,scala,lineno]
----
@tailrec
final def runT: A = resume match {
  case Right(a) => a
  case Left(k)  => k().runT
}

@tailrec
final def resume: Either[() => Trampoline[A], A] = {
  this match {
    case Done(v) => Right(v)
    case More(k) => Left(k)
    case FlatMap(a, f) => a match {
      case Done(v) => f(v).resume
      case More(k) => Left(() => FlatMap(k(), f))
      case FlatMap(b, g) =>
        (FlatMap(b, (x: Any) => FlatMap(g(x), f)):
           Trampoline[A]).resume
    }
  }
}
----

The original `runT` method is refactored, and a new method, `resume` is introduced.
The `resume` method is responsible for determining the next step in the computation.
The new `runT` method just runs the steps.

Let's dive a little deeper into the `resume` method.
First, the return type of `resume` is an `Either`.
So return value has a `Left` or `Right` value.
When the return value has type `Left`, it will contain the next step of the computation.
If the return value has type `Right`, it will contain the return value.
For the pattern matching inside `resume`,
the cases for `Done` and `More` are pretty the same as the original implementation.
What's interesting is the case for `FlatMap`;
the first thing it does is to match on the computation,
first constructor argument for `FlatMap`.
If the computation inside `FlatMap` is a value of type `Done`,
we just pass the value inside `Done` to the continuation,
the second constructor argument for `FlatMap`.
The scenario makes sense so far because `FlatMap` represents the result of a computation should be
passed into the continuation.
The case for `More` is a little more interesting.
Since `More` contains the next step of the computation,
we need _run_ that step first, then feed its result to the continuation.
And we package that up into another computational step that uses `FlatMap`, hence,
`() => FlatMap(k(), f)`.
The most tricky scenario is the `FlatMap` case.
If we land on this case, it implies we have `FlatMap` nested inside another `FlatMap`.
Something like the following:

[source,scala,lineno]
.Nested FlatMaps
----
FlatMap(
  FlatMap(
    FlatMap(..., cont3), cont2), cont1)
----
