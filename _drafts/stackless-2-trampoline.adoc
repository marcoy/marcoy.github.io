= Stackless Scala, Part 2: Trampoline
:page-layout: post
:page-categories: articles
:page-tags: scala, functional programming
:page-liquid:

:part1: link:{% post_url 2016-09-08-stackless-scala-1-the-problem %}

== Quick Recap
In the {part1}[last] post where I went through the `zipIndex` example from RÃºnar's paper.
The `zipIndex` is implemented in functional style Scala, but it has a huge problem --
it is not stack safe.
If the input list is too long, `zipIndex` will throw `StackOverflowError`.

== Trampoline
So how do we get around the stack problem?
Is there a way to avoid creating the stack frames?
At the point, the paper introduces trampoline.
The idea is to "`trade stack for heap`".

[source,scala,lineno]
.Trampoline
----
sealed trait Trampoline[+A] {
  @tailrec // <1>
  final def runT: A =
    this match {
      case More(k) => k().runT
      case Done(v) => v
    }
}
case class More[+A](k: () => Trampoline[A])
    extends Trampoline[A]
case class Done[+A](result: A) extends Trampoline[A]
----
<1> Tell the Scala compiler to apply tail-call optimisation.
    As such, no new stack frame will be created when `runT` calls itself.

Trampoline is an ADT that captures the steps of a computation.
In order words, given a computation that will return a value of type `A`
(correspond to the covariant type variable for `Trampoline`),
that computation can be represented as `More` or `Done`.
A `Done` signifies that computation is done,
and the value inside `Done` will be used as the return value.
A `More` indicates that are a least a more step to perform for the computation.
So perform the step inside `More`, then see what the next step will be.

[sidebar]
.Trampoline in Haskell
****
As an aside, I much prefer the Haskell syntax; it is much more concise.
Below is the implementation of `runT` and the `Trampoline` ADT in Haskell.

[source,haskell]
----
data Trampoline a = More (() -> Trampoline a)
                  | Done a

runT :: Trampoline a -> a
runT (Done a) = a
runT (More k) = runT (k ())
----
****

=== Trampoline Example: Odd and Even
After introducing `Trampoline` ADT, the paper shows a simple example on how to use it.
The `odd` and `even` functions do as their names say,
and they call each other in a mutual recursion way --
meaning at the last step of `odd` it calls `even` and vice versa.
Since we are using `Trampoline` to represent the `odd` and `even` computations,
and both of those computations return Boolean.
So the return types for `odd` and `even` will be `Trampoline[Boolean]`.

Let's see some code!

[source,scala,lineno]
----
def even[A](ns: List[A]): Trampoline[Boolean] = // <1>
  ns match {
    case Nil => Done(true)
    case x :: xs => More(() => odd(xs)) // <2>
  }

def odd[A](ns: List[A]): Trampoline[Boolean] = // <1>
  ns match {
    case Nil => Done(false)
    case x :: xs => More(() => even(xs)) // <2>
  }

even(List(1,2,3)).runT // -> False <3>
----
<1> Return `Trampoline[Boolean]` rather than just `Boolean`.
<2> Mutual recursion.
<3> Run the computation.

After calling `even(List(1,2,3))`, we get a value of type `Trampoline[Boolean]`.
The value represents all the steps in the `even` computation.
So in order to get the `Boolean` value out, we will need to run those steps.
Hence, we need to call `runT` on the return value of `even`.

Normally, if `even` and `odd` mutually call each other and they return `Boolean` values,
the call, `even(List.fill(4000)(1))`, will overflow the stack.
That is because at the end of `even` it calls `odd` before it can return.
Thus, creating a new stack frame for every single element in the input list.
By utilizing `Trampoline`, instead of having `even` call `odd`,
`even` just return a step (`More`) to `runT`.
